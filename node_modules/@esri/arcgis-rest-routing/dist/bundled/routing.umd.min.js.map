{"version":3,"file":"routing.umd.min.js","sources":["../../src/helpers.ts","../../../../node_modules/@terraformer/arcgis/dist/t-arcgis.esm.js","../../src/solveRoute.ts","../../src/closestFacility.ts","../../src/serviceArea.ts","../../src/originDestinationMatrix.ts"],"sourcesContent":["/* Copyright (c) 2018 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n\nimport {\n  IRequestOptions,\n  ILocation,\n  IPoint,\n  IPolyline,\n  Position2D,\n  IFeatureSet\n} from \"@esri/arcgis-rest-request\";\n\n// https always\nexport const ARCGIS_ONLINE_ROUTING_URL =\n  \"https://route.arcgis.com/arcgis/rest/services/World/Route/NAServer/Route_World\";\nexport const ARCGIS_ONLINE_CLOSEST_FACILITY_URL =\n  \"https://route.arcgis.com/arcgis/rest/services/World/ClosestFacility/NAServer/ClosestFacility_World\";\nexport const ARCGIS_ONLINE_SERVICE_AREA_URL =\n  \"https://route.arcgis.com/arcgis/rest/services/World/ServiceAreas/NAServer/ServiceArea_World\";\nexport const ARCGIS_ONLINE_ORIGIN_DESTINATION_MATRIX_URL =\n  \"https://route.arcgis.com/arcgis/rest/services/World/OriginDestinationCostMatrix/NAServer/OriginDestinationCostMatrix_World\";\n\n// nice to have: verify custom endpoints contain 'NAServer' and end in a '/'\nexport interface IEndpointOptions extends IRequestOptions {\n  /**\n   * Any ArcGIS Routing service (example: https://sampleserver3.arcgisonline.com/ArcGIS/rest/services/Network/USA/NAServer/Route/ ) to use for the routing service request.\n   */\n  endpoint?: string;\n}\n\nfunction isLocationArray(\n  coords: ILocation | IPoint | [number, number] | [number, number, number]\n): coords is [number, number] | [number, number, number] {\n  return (\n    (coords as [number, number]).length === 2 ||\n    (coords as [number, number, number]).length === 3\n  );\n}\n\nfunction isLocation(\n  coords: ILocation | IPoint | [number, number] | [number, number, number]\n): coords is ILocation {\n  return (\n    (coords as ILocation).latitude !== undefined ||\n    (coords as ILocation).lat !== undefined\n  );\n}\n\nexport function normalizeLocationsList(\n  locations: Array<IPoint | ILocation | [number, number]>\n): string[] {\n  return locations.map((coords) => {\n    if (isLocationArray(coords)) {\n      return coords.join();\n    } else if (isLocation(coords)) {\n      if (coords.lat) {\n        return coords.long + \",\" + coords.lat;\n      } else {\n        return coords.longitude + \",\" + coords.latitude;\n      }\n    } else {\n      return coords.x + \",\" + coords.y;\n    }\n  });\n}\n\nexport function decompressGeometry(str: string) {\n  let xDiffPrev = 0;\n  let yDiffPrev = 0;\n  const points = [];\n  let x;\n  let y;\n\n  // Split the string into an array on the + and - characters\n  const strings = str.match(/((\\+|-)[^+-]+)/g);\n\n  // The first value is the coefficient in base 32\n  const coefficient = parseInt(strings[0], 32);\n\n  for (let j = 1; j < strings.length; j += 2) {\n    // j is the offset for the x value\n    // Convert the value from base 32 and add the previous x value\n    x = parseInt(strings[j], 32) + xDiffPrev;\n    xDiffPrev = x;\n\n    // j+1 is the offset for the y value\n    // Convert the value from base 32 and add the previous y value\n    y = parseInt(strings[j + 1], 32) + yDiffPrev;\n    yDiffPrev = y;\n\n    points.push([x / coefficient, y / coefficient] as Position2D);\n  }\n\n  return {\n    paths: [points]\n  } as IPolyline;\n}\n\n/**\n * User Defined Type Guard that verifies this is a featureSet\n */\nexport function isFeatureSet(arg: any): arg is IFeatureSet {\n  return Object.prototype.hasOwnProperty.call(arg, \"features\");\n}\n\n/**\n * User Defined Type Guard that verifies this is a JSON with `url` property\n */\nexport function isJsonWithURL(arg: any): arg is Object {\n  return \"url\" in arg;\n}\n","/* @preserve\n* @terraformer/arcgis - v2.0.7 - MIT\n* Copyright (c) 2012-2021 Environmental Systems Research Institute, Inc.\n* Thu Jul 22 2021 13:58:30 GMT-0700 (Pacific Daylight Time)\n*/\n/* Copyright (c) 2012-2019 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n\nvar edgeIntersectsEdge = function edgeIntersectsEdge(a1, a2, b1, b2) {\n  var uaT = (b2[0] - b1[0]) * (a1[1] - b1[1]) - (b2[1] - b1[1]) * (a1[0] - b1[0]);\n  var ubT = (a2[0] - a1[0]) * (a1[1] - b1[1]) - (a2[1] - a1[1]) * (a1[0] - b1[0]);\n  var uB = (b2[1] - b1[1]) * (a2[0] - a1[0]) - (b2[0] - b1[0]) * (a2[1] - a1[1]);\n\n  if (uB !== 0) {\n    var ua = uaT / uB;\n    var ub = ubT / uB;\n\n    if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {\n      return true;\n    }\n  }\n\n  return false;\n};\nvar coordinatesContainPoint = function coordinatesContainPoint(coordinates, point) {\n  var contains = false;\n\n  for (var i = -1, l = coordinates.length, j = l - 1; ++i < l; j = i) {\n    if ((coordinates[i][1] <= point[1] && point[1] < coordinates[j][1] || coordinates[j][1] <= point[1] && point[1] < coordinates[i][1]) && point[0] < (coordinates[j][0] - coordinates[i][0]) * (point[1] - coordinates[i][1]) / (coordinates[j][1] - coordinates[i][1]) + coordinates[i][0]) {\n      contains = !contains;\n    }\n  }\n\n  return contains;\n};\nvar pointsEqual = function pointsEqual(a, b) {\n  for (var i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n\n  return true;\n};\nvar arrayIntersectsArray = function arrayIntersectsArray(a, b) {\n  for (var i = 0; i < a.length - 1; i++) {\n    for (var j = 0; j < b.length - 1; j++) {\n      if (edgeIntersectsEdge(a[i], a[i + 1], b[j], b[j + 1])) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\n/* Copyright (c) 2012-2019 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n\nvar closeRing = function closeRing(coordinates) {\n  if (!pointsEqual(coordinates[0], coordinates[coordinates.length - 1])) {\n    coordinates.push(coordinates[0]);\n  }\n\n  return coordinates;\n}; // determine if polygon ring coordinates are clockwise. clockwise signifies outer ring, counter-clockwise an inner ring\n// or hole. this logic was found at http://stackoverflow.com/questions/1165647/how-to-determine-if-a-list-of-polygon-\n// points-are-in-clockwise-order\n\nvar ringIsClockwise = function ringIsClockwise(ringToTest) {\n  var total = 0;\n  var i = 0;\n  var rLength = ringToTest.length;\n  var pt1 = ringToTest[i];\n  var pt2;\n\n  for (i; i < rLength - 1; i++) {\n    pt2 = ringToTest[i + 1];\n    total += (pt2[0] - pt1[0]) * (pt2[1] + pt1[1]);\n    pt1 = pt2;\n  }\n\n  return total >= 0;\n}; // This function ensures that rings are oriented in the right directions\n// from http://jsperf.com/cloning-an-object/2\n\nvar shallowClone = function shallowClone(obj) {\n  var target = {};\n\n  for (var i in obj) {\n    // both arcgis attributes and geojson props are just hardcoded keys\n    if (obj.hasOwnProperty(i)) {\n      // eslint-disable-line no-prototype-builtins\n      target[i] = obj[i];\n    }\n  }\n\n  return target;\n};\n\n/* Copyright (c) 2012-2019 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n\nvar coordinatesContainCoordinates = function coordinatesContainCoordinates(outer, inner) {\n  var intersects = arrayIntersectsArray(outer, inner);\n  var contains = coordinatesContainPoint(outer, inner[0]);\n\n  if (!intersects && contains) {\n    return true;\n  }\n\n  return false;\n}; // do any polygons in this array contain any other polygons in this array?\n// used for checking for holes in arcgis rings\n\n\nvar convertRingsToGeoJSON = function convertRingsToGeoJSON(rings) {\n  var outerRings = [];\n  var holes = [];\n  var x; // iterator\n\n  var outerRing; // current outer ring being evaluated\n\n  var hole; // current hole being evaluated\n  // for each ring\n\n  for (var r = 0; r < rings.length; r++) {\n    var ring = closeRing(rings[r].slice(0));\n\n    if (ring.length < 4) {\n      continue;\n    } // is this ring an outer ring? is it clockwise?\n\n\n    if (ringIsClockwise(ring)) {\n      var polygon = [ring.slice().reverse()]; // wind outer rings counterclockwise for RFC 7946 compliance\n\n      outerRings.push(polygon); // push to outer rings\n    } else {\n      holes.push(ring.slice().reverse()); // wind inner rings clockwise for RFC 7946 compliance\n    }\n  }\n\n  var uncontainedHoles = []; // while there are holes left...\n\n  while (holes.length) {\n    // pop a hole off out stack\n    hole = holes.pop(); // loop over all outer rings and see if they contain our hole.\n\n    var contained = false;\n\n    for (x = outerRings.length - 1; x >= 0; x--) {\n      outerRing = outerRings[x][0];\n\n      if (coordinatesContainCoordinates(outerRing, hole)) {\n        // the hole is contained push it into our polygon\n        outerRings[x].push(hole);\n        contained = true;\n        break;\n      }\n    } // ring is not contained in any outer ring\n    // sometimes this happens https://github.com/Esri/esri-leaflet/issues/320\n\n\n    if (!contained) {\n      uncontainedHoles.push(hole);\n    }\n  } // if we couldn't match any holes using contains we can try intersects...\n\n\n  while (uncontainedHoles.length) {\n    // pop a hole off out stack\n    hole = uncontainedHoles.pop(); // loop over all outer rings and see if any intersect our hole.\n\n    var intersects = false;\n\n    for (x = outerRings.length - 1; x >= 0; x--) {\n      outerRing = outerRings[x][0];\n\n      if (arrayIntersectsArray(outerRing, hole)) {\n        // the hole is contained push it into our polygon\n        outerRings[x].push(hole);\n        intersects = true;\n        break;\n      }\n    }\n\n    if (!intersects) {\n      outerRings.push([hole.reverse()]);\n    }\n  }\n\n  if (outerRings.length === 1) {\n    return {\n      type: 'Polygon',\n      coordinates: outerRings[0]\n    };\n  } else {\n    return {\n      type: 'MultiPolygon',\n      coordinates: outerRings\n    };\n  }\n};\n\nvar getId = function getId(attributes, idAttribute) {\n  var keys = idAttribute ? [idAttribute, 'OBJECTID', 'FID'] : ['OBJECTID', 'FID'];\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n\n    if (key in attributes && (typeof attributes[key] === 'string' || typeof attributes[key] === 'number')) {\n      return attributes[key];\n    }\n  }\n\n  throw Error('No valid id attribute found');\n};\n\nvar arcgisToGeoJSON = function arcgisToGeoJSON(arcgis, idAttribute) {\n  var geojson = {};\n\n  if (arcgis.features) {\n    geojson.type = 'FeatureCollection';\n    geojson.features = [];\n\n    for (var i = 0; i < arcgis.features.length; i++) {\n      geojson.features.push(arcgisToGeoJSON(arcgis.features[i], idAttribute));\n    }\n  }\n\n  if (typeof arcgis.x === 'number' && typeof arcgis.y === 'number') {\n    geojson.type = 'Point';\n    geojson.coordinates = [arcgis.x, arcgis.y];\n\n    if (typeof arcgis.z === 'number') {\n      geojson.coordinates.push(arcgis.z);\n    }\n  }\n\n  if (arcgis.points) {\n    geojson.type = 'MultiPoint';\n    geojson.coordinates = arcgis.points.slice(0);\n  }\n\n  if (arcgis.paths) {\n    if (arcgis.paths.length === 1) {\n      geojson.type = 'LineString';\n      geojson.coordinates = arcgis.paths[0].slice(0);\n    } else {\n      geojson.type = 'MultiLineString';\n      geojson.coordinates = arcgis.paths.slice(0);\n    }\n  }\n\n  if (arcgis.rings) {\n    geojson = convertRingsToGeoJSON(arcgis.rings.slice(0));\n  }\n\n  if (typeof arcgis.xmin === 'number' && typeof arcgis.ymin === 'number' && typeof arcgis.xmax === 'number' && typeof arcgis.ymax === 'number') {\n    geojson.type = 'Polygon';\n    geojson.coordinates = [[[arcgis.xmax, arcgis.ymax], [arcgis.xmin, arcgis.ymax], [arcgis.xmin, arcgis.ymin], [arcgis.xmax, arcgis.ymin], [arcgis.xmax, arcgis.ymax]]];\n  }\n\n  if (arcgis.geometry || arcgis.attributes) {\n    geojson.type = 'Feature';\n    geojson.geometry = arcgis.geometry ? arcgisToGeoJSON(arcgis.geometry) : null;\n    geojson.properties = arcgis.attributes ? shallowClone(arcgis.attributes) : null;\n\n    if (arcgis.attributes) {\n      try {\n        geojson.id = getId(arcgis.attributes, idAttribute);\n      } catch (err) {// don't set an id\n      }\n    }\n  } // if no valid geometry was encountered\n\n\n  if (JSON.stringify(geojson.geometry) === JSON.stringify({})) {\n    geojson.geometry = null;\n  }\n\n  if (arcgis.spatialReference && arcgis.spatialReference.wkid && arcgis.spatialReference.wkid !== 4326) {\n    console.warn('Object converted in non-standard crs - ' + JSON.stringify(arcgis.spatialReference));\n  }\n\n  return geojson;\n};\n\n/* Copyright (c) 2012-2019 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n// outer rings are clockwise, holes are counterclockwise\n// used for converting GeoJSON Polygons to ArcGIS Polygons\n\nvar orientRings = function orientRings(poly) {\n  var output = [];\n  var polygon = poly.slice(0);\n  var outerRing = closeRing(polygon.shift().slice(0));\n\n  if (outerRing.length >= 4) {\n    if (!ringIsClockwise(outerRing)) {\n      outerRing.reverse();\n    }\n\n    output.push(outerRing);\n\n    for (var i = 0; i < polygon.length; i++) {\n      var hole = closeRing(polygon[i].slice(0));\n\n      if (hole.length >= 4) {\n        if (ringIsClockwise(hole)) {\n          hole.reverse();\n        }\n\n        output.push(hole);\n      }\n    }\n  }\n\n  return output;\n}; // This function flattens holes in multipolygons to one array of polygons\n// used for converting GeoJSON Polygons to ArcGIS Polygons\n\n\nvar flattenMultiPolygonRings = function flattenMultiPolygonRings(rings) {\n  var output = [];\n\n  for (var i = 0; i < rings.length; i++) {\n    var polygon = orientRings(rings[i]);\n\n    for (var x = polygon.length - 1; x >= 0; x--) {\n      var ring = polygon[x].slice(0);\n      output.push(ring);\n    }\n  }\n\n  return output;\n};\n\nvar geojsonToArcGIS = function geojsonToArcGIS(geojson, idAttribute) {\n  idAttribute = idAttribute || 'OBJECTID';\n  var spatialReference = {\n    wkid: 4326\n  };\n  var result = {};\n  var i;\n\n  switch (geojson.type) {\n    case 'Point':\n      result.x = geojson.coordinates[0];\n      result.y = geojson.coordinates[1];\n\n      if (geojson.coordinates[2]) {\n        result.z = geojson.coordinates[2];\n      }\n\n      result.spatialReference = spatialReference;\n      break;\n\n    case 'MultiPoint':\n      result.points = geojson.coordinates.slice(0);\n\n      if (geojson.coordinates[0][2]) {\n        result.hasZ = true;\n      }\n\n      result.spatialReference = spatialReference;\n      break;\n\n    case 'LineString':\n      result.paths = [geojson.coordinates.slice(0)];\n\n      if (geojson.coordinates[0][2]) {\n        result.hasZ = true;\n      }\n\n      result.spatialReference = spatialReference;\n      break;\n\n    case 'MultiLineString':\n      result.paths = geojson.coordinates.slice(0);\n\n      if (geojson.coordinates[0][0][2]) {\n        result.hasZ = true;\n      }\n\n      result.spatialReference = spatialReference;\n      break;\n\n    case 'Polygon':\n      result.rings = orientRings(geojson.coordinates.slice(0));\n\n      if (geojson.coordinates[0][0][2]) {\n        result.hasZ = true;\n      }\n\n      result.spatialReference = spatialReference;\n      break;\n\n    case 'MultiPolygon':\n      result.rings = flattenMultiPolygonRings(geojson.coordinates.slice(0));\n\n      if (geojson.coordinates[0][0][0][2]) {\n        result.hasZ = true;\n      }\n\n      result.spatialReference = spatialReference;\n      break;\n\n    case 'Feature':\n      if (geojson.geometry) {\n        result.geometry = geojsonToArcGIS(geojson.geometry, idAttribute);\n      }\n\n      result.attributes = geojson.properties ? shallowClone(geojson.properties) : {};\n\n      if (geojson.id) {\n        result.attributes[idAttribute] = geojson.id;\n      }\n\n      break;\n\n    case 'FeatureCollection':\n      result = [];\n\n      for (i = 0; i < geojson.features.length; i++) {\n        result.push(geojsonToArcGIS(geojson.features[i], idAttribute));\n      }\n\n      break;\n\n    case 'GeometryCollection':\n      result = [];\n\n      for (i = 0; i < geojson.geometries.length; i++) {\n        result.push(geojsonToArcGIS(geojson.geometries[i], idAttribute));\n      }\n\n      break;\n  }\n\n  return result;\n};\n\n/* Copyright (c) 2012-2019 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n\nexport { arcgisToGeoJSON, geojsonToArcGIS };\n","/* Copyright (c) 2018 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n\nimport {\n  request,\n  cleanUrl,\n  ILocation,\n  IPoint,\n  IFeature,\n  IFeatureSet\n} from \"@esri/arcgis-rest-request\";\n\nimport {\n  ARCGIS_ONLINE_ROUTING_URL,\n  IEndpointOptions,\n  decompressGeometry,\n  isFeatureSet\n} from \"./helpers.js\";\n\nimport { arcgisToGeoJSON } from \"@terraformer/arcgis\";\n\ninterface IFeatureWithCompressedGeometry extends IFeature {\n  compressedGeometry?: string;\n}\n\ninterface IFeatureSetWithGeoJson extends IFeatureSet {\n  geoJson?: {};\n}\n\nexport interface ISolveRouteOptions extends IEndpointOptions {\n  /**\n   * Specify two or more locations between which the route is to be found.\n   */\n  stops:\n    | Array<IPoint | ILocation | [number, number] | [number, number, number]>\n    | IFeatureSet;\n}\n\nexport interface ISolveRouteResponse {\n  messages: string[];\n  checksum: string;\n  routes: IFeatureSetWithGeoJson;\n  directions?: Array<{\n    routeId: number;\n    routeName: string;\n    summary: object;\n    features: IFeature[];\n  }>;\n}\n\nfunction isLocationArray(\n  coords: ILocation | IPoint | [number, number] | [number, number, number]\n): coords is [number, number] | [number, number, number] {\n  return (\n    (coords as [number, number]).length === 2 ||\n    (coords as [number, number, number]).length === 3\n  );\n}\n\nfunction isLocation(\n  coords: ILocation | IPoint | [number, number] | [number, number, number]\n): coords is ILocation {\n  return (\n    (coords as ILocation).latitude !== undefined ||\n    (coords as ILocation).lat !== undefined\n  );\n}\n\n/**\n * Used to find the best way to get from one location to another or to visit several locations. See the [REST Documentation](https://developers.arcgis.com/rest/network/api-reference/route-synchronous-service.htm) for more information.\n *\n * ```js\n * import { solveRoute } from '@esri/arcgis-rest-routing';\n *\n * solveRoute({\n *   stops: [\n *     [-117.195677, 34.056383],\n *     [-117.918976, 33.812092],\n *    ],\n *    authentication\n * })\n *   .then(response) // => {routes: {features: [{attributes: { ... }, geometry:{ ... }}]}\n * ```\n *\n * @param requestOptions Options to pass through to the routing service.\n * @returns A Promise that will resolve with routes and directions for the request.\n * @restlink https://developers.arcgis.com/rest/network/api-reference/route-synchronous-service.htm\n */\nexport function solveRoute(\n  requestOptions: ISolveRouteOptions\n): Promise<ISolveRouteResponse> {\n  const options: ISolveRouteOptions = {\n    endpoint: requestOptions.endpoint || ARCGIS_ONLINE_ROUTING_URL,\n    params: {},\n    ...requestOptions\n  };\n\n  // the SAAS service does not support anonymous requests\n  if (\n    !requestOptions.authentication &&\n    options.endpoint === ARCGIS_ONLINE_ROUTING_URL\n  ) {\n    return Promise.reject(\n      \"Routing using the ArcGIS service requires authentication\"\n    );\n  }\n\n  if (isFeatureSet(requestOptions.stops)) {\n    options.params.stops = requestOptions.stops;\n  } else {\n    const stops: string[] = requestOptions.stops.map((coords) => {\n      if (isLocationArray(coords)) {\n        return coords.join();\n      } else if (isLocation(coords)) {\n        if (coords.lat) {\n          return (\n            coords.long + \",\" + coords.lat + (coords.z ? \",\" + coords.z : \"\")\n          );\n        } else {\n          return (\n            coords.longitude +\n            \",\" +\n            coords.latitude +\n            (coords.z ? \",\" + coords.z : \"\")\n          );\n        }\n      } else {\n        return coords.x + \",\" + coords.y + (coords.z ? \",\" + coords.z : \"\");\n      }\n    });\n\n    options.params.stops = stops.join(\";\");\n  }\n\n  return request(`${cleanUrl(options.endpoint)}/solve`, options).then(\n    cleanResponse\n  );\n}\n\nfunction cleanResponse(res: any): ISolveRouteResponse {\n  if (res.directions && res.directions.length > 0) {\n    res.directions = res.directions.map(\n      (direction: {\n        features: IFeatureWithCompressedGeometry[];\n        routeId: number;\n        routeName: string;\n        summary: {};\n      }) => {\n        direction.features = direction.features.map(\n          (feature: IFeatureWithCompressedGeometry) => {\n            feature.geometry = decompressGeometry(feature.compressedGeometry);\n            return feature;\n          }\n        );\n        return direction;\n      }\n    );\n  }\n\n  // add \"geoJson\" property to \"routes\"\n  if (res.routes.spatialReference.wkid === 4326) {\n    const features = res.routes.features.map((feature: any) => {\n      return {\n        type: \"Feature\",\n        geometry: arcgisToGeoJSON(feature.geometry),\n        properties: Object.assign({}, feature.attributes)\n      };\n    });\n\n    res.routes.geoJson = {\n      type: \"FeatureCollection\",\n      features\n    };\n  }\n  return res;\n}\n\nexport default {\n  solveRoute\n};\n","/* Copyright (c) 2018 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n\nimport {\n  request,\n  cleanUrl,\n  appendCustomParams,\n  ILocation,\n  IPoint,\n  IFeature,\n  IFeatureSet\n} from \"@esri/arcgis-rest-request\";\n\nimport {\n  ARCGIS_ONLINE_CLOSEST_FACILITY_URL,\n  IEndpointOptions,\n  normalizeLocationsList,\n  isFeatureSet,\n  isJsonWithURL\n} from \"./helpers.js\";\n\nimport { arcgisToGeoJSON } from \"@terraformer/arcgis\";\n\nexport interface IClosestFacilityOptions extends IEndpointOptions {\n  /**\n   * Specify one or more locations from which the service searches for the nearby locations. These locations are referred to as incidents.\n   */\n  incidents:\n    | Array<IPoint | ILocation | [number, number]>\n    | IFeatureSet\n    | { url: string };\n\n  /**\n   * Specify one or more locations that are searched for when finding the closest location.\n   */\n  facilities:\n    | Array<IPoint | ILocation | [number, number]>\n    | IFeatureSet\n    | { url: string };\n  /**\n   *  Specify if the service should return routes.\n   */\n  returnCFRoutes: boolean;\n  travelDirection?: \"incidentsToFacilities\" | \"facilitiesToIncidents\";\n  barriers?: Array<IPoint | ILocation | [number, number]> | IFeatureSet;\n  polylineBarriers?: IFeatureSet;\n  polygonBarriers?: IFeatureSet;\n  returnDirections?: boolean;\n  directionsOutputType?:\n    | \"esriDOTComplete\"\n    | \"esriDOTCompleteNoEvents\"\n    | \"esriDOTInstructionsOnly\"\n    | \"esriDOTStandard\"\n    | \"esriDOTSummaryOnly\"\n    | \"esriDOTFeatureSets\";\n  directionsLengthUnits?:\n    | \"esriNAUCentimeters\"\n    | \"esriNAUDecimalDegrees\"\n    | \"esriNAUDecimeters\"\n    | \"esriNAUFeet\"\n    | \"esriNAUInches\"\n    | \"esriNAUKilometers\"\n    | \"esriNAUMeters\"\n    | \"esriNAUMiles\"\n    | \"esriNAUMillimeters\"\n    | \"esriNAUNauticalMiles\"\n    | \"esriNAUPoints\"\n    | \"esriNAUYards\";\n  outputLines?: boolean;\n  returnFacilities?: boolean;\n  returnIncidents?: boolean;\n  returnBarriers?: boolean;\n  returnPolylineBarriers?: boolean;\n  returnPolygonBarriers?: boolean;\n  preserveObjectID?: boolean;\n}\n\ninterface IFeatureSetWithGeoJson extends IFeatureSet {\n  geoJson?: any;\n}\n\nexport interface IClosestFacilityResponse {\n  messages: string[];\n  routes?: IFeatureSetWithGeoJson;\n  directions?: Array<{\n    routeId: number;\n    routeName: string;\n    summary: object;\n    features: IFeature[];\n  }>;\n  incidents?: IFeatureSet;\n  facilities?: IFeatureSet;\n  barriers?: IFeatureSet;\n  polygonBarriers?: IFeatureSet;\n  polylineBarriers?: IFeatureSet;\n}\n\nfunction getTravelDirection(\n  key: \"incidentsToFacilities\" | \"facilitiesToIncidents\"\n): \"esriNATravelDirectionFromFacility\" | \"esriNATravelDirectionToFacility\" {\n  if (key === \"incidentsToFacilities\") {\n    return \"esriNATravelDirectionFromFacility\";\n  } else {\n    return \"esriNATravelDirectionToFacility\";\n  }\n}\n\n/**\n * Used to find a route to the nearest of several possible destinations. See the [REST Documentation](https://developers.arcgis.com/rest/network/api-reference/closest-facility-synchronous-service.htm) for more information.\n *\n * ```js\n * import { closestFacility } from '@esri/arcgis-rest-routing';\n *\n * closestFacility({\n *   incidents: [\n *     [-90.404302, 38.600621],\n *     [-90.364293, 38.620427],\n *    ],\n *   facilities: [\n *     [-90.444716, 38.635501],\n *     [-90.311919, 38.633523],\n *     [-90.451147, 38.581107]\n *    ],\n *    authentication\n * })\n *   .then(response) // => {routes: {features: [{attributes: { ... }, geometry:{ ... }}]}\n * ```\n *\n * @param requestOptions Options to pass through to the routing service.\n * @returns A Promise that will resolve with routes and directions for the request.\n * @restlink https://developers.arcgis.com/rest/network/api-reference/closest-facility-synchronous-service.htm\n * @inline IClosestFacilityOptions\n */\nexport function closestFacility(\n  requestOptions: IClosestFacilityOptions\n): Promise<IClosestFacilityResponse> {\n  const endpoint =\n    requestOptions.endpoint || ARCGIS_ONLINE_CLOSEST_FACILITY_URL;\n\n  requestOptions.params = {\n    returnFacilities: true,\n    returnDirections: true,\n    returnIncidents: true,\n    returnBarriers: true,\n    returnPolylineBarriers: true,\n    returnPolygonBarriers: true,\n    preserveObjectID: true,\n    ...requestOptions.params\n  };\n\n  const options = appendCustomParams<IClosestFacilityOptions>(requestOptions, [\n    \"returnCFRoutes\",\n    // \"travelDirection\",\n    \"barriers\",\n    \"polylineBarriers\",\n    \"polygonBarriers\",\n    \"returnDirections\",\n    \"directionsOutputType\",\n    \"directionsLengthUnits\",\n    \"outputLines\",\n    \"returnFacilities\",\n    \"returnIncidents\",\n    \"returnBarriers\",\n    \"returnPolylineBarriers\",\n    \"returnPolygonBarriers\",\n    \"preserveObjectID\"\n  ]);\n\n  // Set travelDirection\n  if (requestOptions.travelDirection) {\n    options.params.travelDirection = getTravelDirection(\n      requestOptions.travelDirection\n    );\n  }\n\n  // the SAAS service does not support anonymous requests\n  if (\n    !requestOptions.authentication &&\n    endpoint === ARCGIS_ONLINE_CLOSEST_FACILITY_URL\n  ) {\n    return Promise.reject(\n      \"Finding the closest facility using the ArcGIS service requires authentication\"\n    );\n  }\n\n  if (\n    isFeatureSet(requestOptions.incidents) ||\n    isJsonWithURL(requestOptions.incidents)\n  ) {\n    options.params.incidents = requestOptions.incidents;\n  } else {\n    options.params.incidents = normalizeLocationsList(\n      requestOptions.incidents\n    ).join(\";\");\n  }\n\n  if (\n    isFeatureSet(requestOptions.facilities) ||\n    isJsonWithURL(requestOptions.facilities)\n  ) {\n    options.params.facilities = requestOptions.facilities;\n  } else {\n    options.params.facilities = normalizeLocationsList(\n      requestOptions.facilities\n    ).join(\";\");\n  }\n\n  // optional input param that may need point geometry normalizing\n  if (requestOptions.barriers) {\n    if (isFeatureSet(requestOptions.barriers)) {\n      options.params.barriers = requestOptions.barriers;\n    } else {\n      // optional point geometry barriers must be normalized, too\n      // but not if provided as IFeatureSet type\n      // note that optional polylineBarriers and polygonBarriers do not need to be normalized\n      options.params.barriers = normalizeLocationsList(\n        requestOptions.barriers\n      ).join(\";\");\n    }\n  }\n\n  return request(`${cleanUrl(endpoint)}/solveClosestFacility`, options).then(\n    cleanResponse\n  );\n}\n\nfunction cleanResponse(res: any): IClosestFacilityResponse {\n  // add \"geoJson\" property to \"routes\"\n  if (res.routes.spatialReference.wkid === 4326) {\n    res.routes.geoJson = arcgisToGeoJSON(res.routes);\n  }\n  return res;\n}\n\nexport default {\n  closestFacility\n};\n","/* Copyright (c) 2018 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n\nimport {\n  request,\n  cleanUrl,\n  appendCustomParams,\n  ILocation,\n  IPoint,\n  IFeatureSet\n} from \"@esri/arcgis-rest-request\";\n\nimport {\n  ARCGIS_ONLINE_SERVICE_AREA_URL,\n  IEndpointOptions,\n  normalizeLocationsList,\n  isFeatureSet\n} from \"./helpers.js\";\n\nimport { arcgisToGeoJSON } from \"@terraformer/arcgis\";\n\nexport interface IServiceAreaOptions extends IEndpointOptions {\n  /**\n   *  Specify one or more locations around which service areas are generated.\n   */\n  facilities: Array<IPoint | ILocation | [number, number]> | IFeatureSet;\n  /**\n   *  Specify if the service should return routes.\n   */\n  travelDirection?: \"incidentsToFacilities\" | \"facilitiesToIncidents\";\n  barriers?: Array<IPoint | ILocation | [number, number]> | IFeatureSet;\n  polylineBarriers?: IFeatureSet;\n  polygonBarriers?: IFeatureSet;\n  outputLines?: boolean;\n  returnFacilities?: boolean;\n  returnBarriers?: boolean;\n  returnPolylineBarriers?: boolean;\n  returnPolygonBarriers?: boolean;\n  preserveObjectID?: boolean;\n}\n\ninterface IFeatureSetWithGeoJson extends IFeatureSet {\n  geoJson?: any;\n}\n\nexport interface IServiceAreaResponse {\n  messages: string[];\n  saPolygons?: IFeatureSetWithGeoJson;\n  incidents?: IFeatureSet;\n  facilities?: IFeatureSet;\n  barriers?: IFeatureSet;\n  polygonBarriers?: IFeatureSet;\n  polylineBarriers?: IFeatureSet;\n}\n\nfunction getTravelDirection(\n  key: \"incidentsToFacilities\" | \"facilitiesToIncidents\"\n): \"esriNATravelDirectionFromFacility\" | \"esriNATravelDirectionToFacility\" {\n  if (key === \"incidentsToFacilities\") {\n    return \"esriNATravelDirectionFromFacility\";\n  } else {\n    return \"esriNATravelDirectionToFacility\";\n  }\n}\n\n/**\n * Used to find the area that can be reached from the input location within a given travel time or travel distance. See the [REST Documentation](https://developers.arcgis.com/rest/network/api-reference/service-area-synchronous-service.htm) for more information.\n *\n * ```js\n * import { serviceArea } from '@esri/arcgis-rest-routing';\n *\n * serviceArea({\n *   facilities: [\n *     [-90.444716, 38.635501],\n *     [-90.311919, 38.633523],\n *     [-90.451147, 38.581107]\n *    ],\n *    authentication\n * })\n *   .then(response) // => {routes: {features: [{attributes: { ... }, geometry:{ ... }}]}\n * ```\n *\n * @param requestOptions Options to pass through to the routing service.\n * @returns A Promise that will resolve with service area polygons for the request.\n * @restlink https://developers.arcgis.com/rest/network/api-reference/service-area-synchronous-service.htm\n */\nexport function serviceArea(\n  requestOptions: IServiceAreaOptions\n): Promise<IServiceAreaResponse> {\n  const endpoint = requestOptions.endpoint || ARCGIS_ONLINE_SERVICE_AREA_URL;\n\n  requestOptions.params = {\n    returnFacilities: true,\n    returnBarriers: true,\n    returnPolylineBarriers: true,\n    returnPolygonBarriers: true,\n    preserveObjectID: true,\n    ...requestOptions.params\n  };\n\n  const options = appendCustomParams<IServiceAreaOptions>(requestOptions, [\n    \"barriers\",\n    \"polylineBarriers\",\n    \"polygonBarriers\",\n    \"outputLines\",\n    \"returnFacilities\",\n    \"returnBarriers\",\n    \"returnPolylineBarriers\",\n    \"returnPolygonBarriers\",\n    \"preserveObjectID\"\n  ]);\n\n  // Set travelDirection\n  if (requestOptions.travelDirection) {\n    options.params.travelDirection = getTravelDirection(\n      requestOptions.travelDirection\n    );\n  }\n\n  // the SAAS service does not support anonymous requests\n  if (\n    !requestOptions.authentication &&\n    endpoint === ARCGIS_ONLINE_SERVICE_AREA_URL\n  ) {\n    return Promise.reject(\n      \"Finding service areas using the ArcGIS service requires authentication\"\n    );\n  }\n\n  if (isFeatureSet(requestOptions.facilities)) {\n    options.params.facilities = requestOptions.facilities;\n  } else {\n    options.params.facilities = normalizeLocationsList(\n      requestOptions.facilities\n    ).join(\";\");\n  }\n\n  // optional input param that may need point geometry normalizing\n  if (requestOptions.barriers) {\n    if (isFeatureSet(requestOptions.barriers)) {\n      options.params.barriers = requestOptions.barriers;\n    } else {\n      // optional point geometry barriers must be normalized, too\n      // but not if provided as IFeatureSet type\n      // note that optional polylineBarriers and polygonBarriers do not need to be normalized\n      options.params.barriers = normalizeLocationsList(\n        requestOptions.barriers\n      ).join(\";\");\n    }\n  }\n\n  return request(`${cleanUrl(endpoint)}/solveServiceArea`, options).then(\n    cleanResponse\n  );\n}\n\nfunction cleanResponse(res: any): IServiceAreaResponse {\n  // remove \"fieldAliases\" because it does not do anything.\n  delete res.saPolygons.fieldAliases;\n\n  // add \"geoJson\" property to \"saPolygons\"\n  if (res.saPolygons.spatialReference.wkid === 4326) {\n    res.saPolygons.geoJson = arcgisToGeoJSON(res.saPolygons);\n  }\n  return res;\n}\n\nexport default {\n  serviceArea\n};\n","/* Copyright (c) 2018 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n\nimport {\n  request,\n  cleanUrl,\n  appendCustomParams,\n  IRequestOptions,\n  ILocation,\n  IPoint,\n  IFeatureSet\n} from \"@esri/arcgis-rest-request\";\n\nimport {\n  ARCGIS_ONLINE_ORIGIN_DESTINATION_MATRIX_URL,\n  IEndpointOptions,\n  normalizeLocationsList,\n  isFeatureSet\n} from \"./helpers.js\";\n\nimport { arcgisToGeoJSON } from \"@terraformer/arcgis\";\n\nexport interface IOriginDestinationMatrixOptions extends IEndpointOptions {\n  /**\n   *  Specify the starting points from which to travel to the destinations.\n   */\n  origins: Array<IPoint | ILocation | [number, number]> | IFeatureSet;\n  /**\n   *  Specify the ending point locations to travel to from the origins.\n   */\n  destinations: Array<IPoint | ILocation | [number, number]> | IFeatureSet;\n  /**\n   *  Specify the type of output returned by the service. Defaults to \"esriNAODOutputSparseMatrix\".\n   */\n  outputType?:\n    | \"esriNAODOutputSparseMatrix\"\n    | \"esriNAODOutputStraightLines\"\n    | \"esriNAODOutputNoLines\";\n  barriers?: Array<IPoint | ILocation | [number, number]> | IFeatureSet;\n  polylineBarriers?: IFeatureSet;\n  polygonBarriers?: IFeatureSet;\n  returnOrigins?: boolean;\n  returnDestinations?: boolean;\n  returnBarriers?: boolean;\n  returnPolylineBarriers?: boolean;\n  returnPolygonBarriers?: boolean;\n}\n\ninterface IFeatureSetWithGeoJson extends IFeatureSet {\n  geoJson?: any;\n}\n\nexport interface IOriginDestinationMatrixResponse {\n  messages: [{ type: number; description: string }];\n  /**\n   *  Only present if outputType is \"esriNAODOutputSparseMatrix\". Full description is available at https://developers.arcgis.com/rest/network/api-reference/origin-destination-cost-matrix-synchronous-service.htm#ESRI_SECTION2_114F8364507C4B56B780DFAD505270FB.\n   */\n  odCostMatrix?: any;\n  /**\n   *  Only present if outputType is \"esriNAODOutputStraightLines\" or \"esriNAODOutputNoLines\". Includes the geometry for the straight line connecting each origin-destination pair when the outputType is \"esriNAODOutputStraightLines\".\n   */\n  odLines?: IFeatureSetWithGeoJson;\n  origins?: IFeatureSetWithGeoJson;\n  destinations?: IFeatureSetWithGeoJson;\n  barriers?: IFeatureSetWithGeoJson;\n  polylineBarriers?: IFeatureSetWithGeoJson;\n  polygonBarriers?: IFeatureSetWithGeoJson;\n}\n\n/**\n * Used to create an origin-destination (OD) cost matrix from multiple origins to multiple destinations. See the [REST Documentation](https://developers.arcgis.com/rest/network/api-reference/origin-destination-cost-matrix-synchronous-service.htm) for more information.\n *\n * ```js\n * import { originDestinationMatrix } from '@esri/arcgis-rest-routing';\n *\n * originDestinationMatrix({\n *   origins: [\n *     [-90.404302, 38.600621],\n *     [-90.364293, 38.620427],\n *   ],\n *   destinations: [\n *     [-90.444716, 38.635501],\n *     [-90.311919, 38.633523],\n *     [-90.451147, 38.581107]\n *   ],\n *   authentication\n * })\n *   .then(response) // => { ... }\n * ```\n *\n * @param requestOptions Options to pass through to the routing service.\n * @returns A Promise that will resolve with travel time and/or distance for each origin-destination pair. It returns either odLines or odCostMatrix for this information depending on the outputType you specify.\n * @restlink https://developers.arcgis.com/rest/network/api-reference/origin-destination-cost-matrix-synchronous-service.htm\n */\nexport function originDestinationMatrix(\n  requestOptions: IOriginDestinationMatrixOptions\n): Promise<IOriginDestinationMatrixResponse> {\n  const endpoint =\n    requestOptions.endpoint || ARCGIS_ONLINE_ORIGIN_DESTINATION_MATRIX_URL;\n\n  requestOptions.params = {\n    outputType: \"esriNAODOutputSparseMatrix\",\n    returnOrigins: true,\n    returnDestinations: true,\n    returnBarriers: true,\n    returnPolylineBarriers: true,\n    returnPolygonBarriers: true,\n    ...requestOptions.params\n  };\n\n  const options = appendCustomParams<IOriginDestinationMatrixOptions>(\n    requestOptions,\n    [\n      \"outputType\",\n      \"barriers\",\n      \"polylineBarriers\",\n      \"polygonBarriers\",\n      \"returnOrigins\",\n      \"returnDestinations\",\n      \"returnBarriers\",\n      \"returnPolylineBarriers\",\n      \"returnPolygonBarriers\"\n    ]\n  );\n\n  // the SAAS service does not support anonymous requests\n  if (\n    !requestOptions.authentication &&\n    endpoint === ARCGIS_ONLINE_ORIGIN_DESTINATION_MATRIX_URL\n  ) {\n    return Promise.reject(\n      \"Calculating the origin-destination cost matrix using the ArcGIS service requires authentication\"\n    );\n  }\n\n  // use a formatting helper for input params of this type: Array<IPoint | ILocation | [number, number]>\n  if (isFeatureSet(requestOptions.origins)) {\n    options.params.origins = requestOptions.origins;\n  } else {\n    options.params.origins = normalizeLocationsList(\n      requestOptions.origins\n    ).join(\";\");\n  }\n\n  if (isFeatureSet(requestOptions.destinations)) {\n    options.params.destinations = requestOptions.destinations;\n  } else {\n    options.params.destinations = normalizeLocationsList(\n      requestOptions.destinations\n    ).join(\";\");\n  }\n\n  // optional input param that may need point geometry normalizing\n  if (requestOptions.barriers) {\n    if (isFeatureSet(requestOptions.barriers)) {\n      options.params.barriers = requestOptions.barriers;\n    } else {\n      // optional point geometry barriers must be normalized, too\n      // but not if provided as IFeatureSet type\n      // note that optional polylineBarriers and polygonBarriers do not need to be normalized\n      options.params.barriers = normalizeLocationsList(\n        requestOptions.barriers\n      ).join(\";\");\n    }\n  }\n\n  return request(`${cleanUrl(endpoint)}/solveODCostMatrix`, options).then(\n    function (res) {\n      return cleanResponse(res, options);\n    }\n  );\n}\n\nfunction cleanResponse(\n  res: any,\n  options: IRequestOptions\n): IOriginDestinationMatrixResponse {\n  // add \"geoJson\" property to each response property that is an arcgis featureSet\n\n  // res.odLines only exists and only includes geometry in this condition (out of 3 possible options.params.outputType conditions)\n  if (\n    options.params.outputType === \"esriNAODOutputStraightLines\" &&\n    res.odLines &&\n    res.odLines.spatialReference.wkid === 4326\n  ) {\n    res.odLines.geoJson = arcgisToGeoJSON(res.odLines);\n  }\n\n  if (res.origins && res.origins.spatialReference.wkid === 4326) {\n    res.origins.geoJson = arcgisToGeoJSON(res.origins);\n  }\n\n  if (res.destinations && res.destinations.spatialReference.wkid === 4326) {\n    res.destinations.geoJson = arcgisToGeoJSON(res.destinations);\n  }\n\n  if (res.barriers && res.barriers.spatialReference.wkid === 4326) {\n    res.barriers.geoJson = arcgisToGeoJSON(res.barriers);\n  }\n\n  if (\n    res.polygonBarriers &&\n    res.polygonBarriers.spatialReference.wkid === 4326\n  ) {\n    res.polygonBarriers.geoJson = arcgisToGeoJSON(res.polygonBarriers);\n  }\n\n  if (\n    res.polylineBarriers &&\n    res.polylineBarriers.spatialReference.wkid === 4326\n  ) {\n    res.polylineBarriers.geoJson = arcgisToGeoJSON(res.polylineBarriers);\n  }\n\n  return res;\n}\n\nexport default {\n  originDestinationMatrix\n};\n"],"names":["ARCGIS_ONLINE_ROUTING_URL","ARCGIS_ONLINE_CLOSEST_FACILITY_URL","ARCGIS_ONLINE_SERVICE_AREA_URL","ARCGIS_ONLINE_ORIGIN_DESTINATION_MATRIX_URL","normalizeLocationsList","locations","map","coords","length","isLocationArray","join","undefined","latitude","lat","isLocation","long","longitude","x","y","decompressGeometry","str","xDiffPrev","yDiffPrev","points","strings","match","coefficient","parseInt","j","push","paths","isFeatureSet","arg","Object","prototype","hasOwnProperty","call","isJsonWithURL","edgeIntersectsEdge","a1","a2","b1","b2","uaT","ubT","uB","ua","ub","arrayIntersectsArray","a","b","i","ringIsClockwise","ringToTest","pt2","total","rLength","pt1","coordinatesContainCoordinates","outer","inner","intersects","contains","coordinates","point","l","coordinatesContainPoint","arcgisToGeoJSON","arcgis","idAttribute","geojson","features","type","z","slice","rings","outerRing","hole","outerRings","holes","r","ring","pointsEqual","polygon","reverse","uncontainedHoles","pop","contained","convertRingsToGeoJSON","xmin","ymin","xmax","ymax","geometry","attributes","properties","obj","target","shallowClone","id","keys","key","Error","getId","err","JSON","stringify","spatialReference","wkid","console","warn","cleanResponse","res","directions","direction","feature","compressedGeometry","routes","assign","geoJson","saPolygons","fieldAliases","requestOptions","endpoint","params","returnFacilities","returnDirections","returnIncidents","returnBarriers","returnPolylineBarriers","returnPolygonBarriers","preserveObjectID","options","appendCustomParams","travelDirection","authentication","incidents","facilities","barriers","request","cleanUrl","then","Promise","reject","outputType","returnOrigins","returnDestinations","origins","destinations","odLines","polygonBarriers","polylineBarriers","stops"],"mappings":"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"}