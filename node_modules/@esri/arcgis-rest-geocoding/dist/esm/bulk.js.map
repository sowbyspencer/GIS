{"version":3,"file":"bulk.js","sourceRoot":"","sources":["../../src/bulk.ts"],"names":[],"mappings":"AAAA;gBACgB;AAEhB,OAAO,EACL,OAAO,EACP,QAAQ,EAGT,MAAM,2BAA2B,CAAC;AAEnC,OAAO,EACL,gCAAgC,EAEjC,MAAM,cAAc,CAAC;AAqCtB;;;;;;;;;;;;;;;;;;;;GAoBG;AACH,MAAM,UAAU,WAAW,CACzB,cAAmC,CAAC,kCAAkC;;IAEtE,MAAM,OAAO,mBACX,QAAQ,EAAE,gCAAgC,EAC1C,MAAM,EAAE,EAAE,IACP,cAAc,CAClB,CAAC;IAEF,OAAO,CAAC,MAAM,CAAC,SAAS,GAAG;QACzB,OAAO,EAAE,cAAc,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,OAAO,EAAE,EAAE;YAChD,OAAO,EAAE,UAAU,EAAE,OAAO,EAAE,CAAC;QACjC,CAAC,CAAC;KACH,CAAC;IAEF,sDAAsD;IACtD,IACE,CAAC,cAAc,CAAC,cAAc;QAC9B,OAAO,CAAC,QAAQ,KAAK,gCAAgC,EACrD;QACA,OAAO,OAAO,CAAC,MAAM,CACnB,iEAAiE,CAClE,CAAC;KACH;IAED,OAAO,OAAO,CACZ,GAAG,QAAQ,CAAC,OAAO,CAAC,QAAQ,CAAC,mBAAmB,EAChD,OAAO,CACR,CAAC,IAAI,CAAC,CAAC,QAAQ,EAAE,EAAE;QAClB,IAAI,OAAO,CAAC,WAAW,EAAE;YACvB,OAAO,QAAQ,CAAC;SACjB;QACD,MAAM,EAAE,GAAG,QAAQ,CAAC,gBAAgB,CAAC;QACrC,QAAQ,CAAC,SAAS,CAAC,OAAO,CAAC,UAAU,OAA6B;YAChE,IAAI,OAAO,CAAC,QAAQ,EAAE;gBACpB,OAAO,CAAC,QAAQ,CAAC,gBAAgB,GAAG,EAAE,CAAC;aACxC;QACH,CAAC,CAAC,CAAC;QACH,OAAO,QAAQ,CAAC;IAClB,CAAC,CAAC,CAAC;AACL,CAAC","sourcesContent":["/* Copyright (c) 2017-2018 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n\nimport {\n  request,\n  cleanUrl,\n  ISpatialReference,\n  IPoint\n} from \"@esri/arcgis-rest-request\";\n\nimport {\n  ARCGIS_ONLINE_BULK_GEOCODING_URL,\n  IEndpointOptions\n} from \"./helpers.js\";\n\n// It would be better if doc did not display these properties in alphabetical order\nexport interface IAddressBulk {\n  /**\n   * A unique id must be passed along for each individual address.\n   */\n  OBJECTID: number;\n  address?: string;\n  address2?: string;\n  address3?: string;\n  neighborhood?: string;\n  city?: string;\n  subregion?: string;\n  /**\n   * The World Geocoding Service considers US states regions.\n   */\n  region?: string;\n  postal?: number;\n  postalExt?: number;\n  countryCode?: string;\n}\n\nexport interface IBulkGeocodeOptions extends IEndpointOptions {\n  addresses: IAddressBulk[];\n}\n\nexport interface IBulkGeocodeResponse {\n  spatialReference: ISpatialReference;\n  locations: Array<{\n    address: string;\n    location?: IPoint; // candidates with a score of 0 wont include a location\n    score: number;\n    attributes: object;\n  }>;\n}\n\n/**\n * Used to geocode a [batch](https://developers.arcgis.com/rest/geocode/api-reference/geocoding-geocode-addresses.htm) of addresses.\n *\n * ```js\n * import { bulkGeocode } from '@esri/arcgis-rest-geocoding';\n * import { ApplicationCredentialsManager } from '@esri/arcgis-rest-request';\n *\n * const addresses = [\n *   { \"OBJECTID\": 1, \"SingleLine\": \"380 New York Street 92373\" },\n *   { \"OBJECTID\": 2, \"SingleLine\": \"1 World Way Los Angeles 90045\" }\n * ];\n *\n * bulkGeocode({ addresses, authentication: session })\n *   .then((response) => {\n *     response.locations[0].location; // => { x: -117, y: 34, spatialReference: { wkid: 4326 } }\n *   });\n * ```\n *\n * @param requestOptions - Request options to pass to the geocoder, including an array of addresses and authentication session.\n * @returns A Promise that will resolve with the data from the response. The spatial reference will be added to address locations unless `rawResponse: true` was passed.\n */\nexport function bulkGeocode(\n  requestOptions: IBulkGeocodeOptions // must POST, which is the default\n): Promise<IBulkGeocodeResponse> {\n  const options: IBulkGeocodeOptions = {\n    endpoint: ARCGIS_ONLINE_BULK_GEOCODING_URL,\n    params: {},\n    ...requestOptions\n  };\n\n  options.params.addresses = {\n    records: requestOptions.addresses.map((address) => {\n      return { attributes: address };\n    })\n  };\n\n  // the SAS service does not support anonymous requests\n  if (\n    !requestOptions.authentication &&\n    options.endpoint === ARCGIS_ONLINE_BULK_GEOCODING_URL\n  ) {\n    return Promise.reject(\n      \"bulk geocoding using the ArcGIS service requires authentication\"\n    );\n  }\n\n  return request(\n    `${cleanUrl(options.endpoint)}/geocodeAddresses`,\n    options\n  ).then((response) => {\n    if (options.rawResponse) {\n      return response;\n    }\n    const sr = response.spatialReference;\n    response.locations.forEach(function (address: { location: IPoint }) {\n      if (address.location) {\n        address.location.spatialReference = sr;\n      }\n    });\n    return response;\n  });\n}\n"]}