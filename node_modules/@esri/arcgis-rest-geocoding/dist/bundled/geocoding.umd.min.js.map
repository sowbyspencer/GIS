{"version":3,"file":"geocoding.umd.min.js","sources":["../../src/helpers.ts","../../../../node_modules/@terraformer/arcgis/dist/t-arcgis.esm.js","../../src/bulk.ts","../../src/geocode.ts","../../src/reverse.ts","../../src/suggest.ts"],"sourcesContent":["/* Copyright (c) 2017 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n\nimport { request, IRequestOptions } from \"@esri/arcgis-rest-request\";\n\n// https always\nexport const ARCGIS_ONLINE_GEOCODING_URL =\n  \"https://geocode-api.arcgis.com/arcgis/rest/services/World/GeocodeServer/\";\nexport const ARCGIS_ONLINE_BULK_GEOCODING_URL =\n  \"https://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer/\";\n\n// nice to have: verify custom endpoints contain 'GeocodeServer' and end in a '/'\nexport interface IEndpointOptions extends IRequestOptions {\n  /**\n   * Any ArcGIS Geocoding service (example: http://sampleserver6.arcgisonline.com/arcgis/rest/services/Locators/SanDiego/GeocodeServer )\n   */\n  endpoint?: string;\n}\n\nexport interface IGetGeocodeServiceResponse {\n  currentVersion: number;\n  serviceDescription: string;\n  addressFields: any[];\n  countries: string[];\n  capabilities: string;\n}\n\n/**\n * Used to fetch metadata from a geocoding service.\n *\n * ```js\n * import { getGeocoderServiceInfo } from '@esri/arcgis-rest-geocoding';\n *\n * getGeocoderServiceInfo()\n *   .then((response) => {\n *     response.serviceDescription; // => 'World Geocoder'\n *   });\n * ```\n *\n * @param requestOptions - Request options can contain a custom geocoding service to fetch metadata from.\n * @returns A Promise that will resolve with the data from the response.\n */\nexport function getGeocodeService(\n  requestOptions?: IEndpointOptions\n): Promise<IGetGeocodeServiceResponse> {\n  const url =\n    (requestOptions && requestOptions.endpoint) || ARCGIS_ONLINE_GEOCODING_URL;\n\n  const options: IEndpointOptions = {\n    httpMethod: \"GET\",\n    maxUrlLength: 2000,\n    ...requestOptions\n  };\n\n  return request(url, options);\n}\n","/* @preserve\n* @terraformer/arcgis - v2.0.7 - MIT\n* Copyright (c) 2012-2021 Environmental Systems Research Institute, Inc.\n* Thu Jul 22 2021 13:58:30 GMT-0700 (Pacific Daylight Time)\n*/\n/* Copyright (c) 2012-2019 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n\nvar edgeIntersectsEdge = function edgeIntersectsEdge(a1, a2, b1, b2) {\n  var uaT = (b2[0] - b1[0]) * (a1[1] - b1[1]) - (b2[1] - b1[1]) * (a1[0] - b1[0]);\n  var ubT = (a2[0] - a1[0]) * (a1[1] - b1[1]) - (a2[1] - a1[1]) * (a1[0] - b1[0]);\n  var uB = (b2[1] - b1[1]) * (a2[0] - a1[0]) - (b2[0] - b1[0]) * (a2[1] - a1[1]);\n\n  if (uB !== 0) {\n    var ua = uaT / uB;\n    var ub = ubT / uB;\n\n    if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {\n      return true;\n    }\n  }\n\n  return false;\n};\nvar coordinatesContainPoint = function coordinatesContainPoint(coordinates, point) {\n  var contains = false;\n\n  for (var i = -1, l = coordinates.length, j = l - 1; ++i < l; j = i) {\n    if ((coordinates[i][1] <= point[1] && point[1] < coordinates[j][1] || coordinates[j][1] <= point[1] && point[1] < coordinates[i][1]) && point[0] < (coordinates[j][0] - coordinates[i][0]) * (point[1] - coordinates[i][1]) / (coordinates[j][1] - coordinates[i][1]) + coordinates[i][0]) {\n      contains = !contains;\n    }\n  }\n\n  return contains;\n};\nvar pointsEqual = function pointsEqual(a, b) {\n  for (var i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n\n  return true;\n};\nvar arrayIntersectsArray = function arrayIntersectsArray(a, b) {\n  for (var i = 0; i < a.length - 1; i++) {\n    for (var j = 0; j < b.length - 1; j++) {\n      if (edgeIntersectsEdge(a[i], a[i + 1], b[j], b[j + 1])) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\n/* Copyright (c) 2012-2019 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n\nvar closeRing = function closeRing(coordinates) {\n  if (!pointsEqual(coordinates[0], coordinates[coordinates.length - 1])) {\n    coordinates.push(coordinates[0]);\n  }\n\n  return coordinates;\n}; // determine if polygon ring coordinates are clockwise. clockwise signifies outer ring, counter-clockwise an inner ring\n// or hole. this logic was found at http://stackoverflow.com/questions/1165647/how-to-determine-if-a-list-of-polygon-\n// points-are-in-clockwise-order\n\nvar ringIsClockwise = function ringIsClockwise(ringToTest) {\n  var total = 0;\n  var i = 0;\n  var rLength = ringToTest.length;\n  var pt1 = ringToTest[i];\n  var pt2;\n\n  for (i; i < rLength - 1; i++) {\n    pt2 = ringToTest[i + 1];\n    total += (pt2[0] - pt1[0]) * (pt2[1] + pt1[1]);\n    pt1 = pt2;\n  }\n\n  return total >= 0;\n}; // This function ensures that rings are oriented in the right directions\n// from http://jsperf.com/cloning-an-object/2\n\nvar shallowClone = function shallowClone(obj) {\n  var target = {};\n\n  for (var i in obj) {\n    // both arcgis attributes and geojson props are just hardcoded keys\n    if (obj.hasOwnProperty(i)) {\n      // eslint-disable-line no-prototype-builtins\n      target[i] = obj[i];\n    }\n  }\n\n  return target;\n};\n\n/* Copyright (c) 2012-2019 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n\nvar coordinatesContainCoordinates = function coordinatesContainCoordinates(outer, inner) {\n  var intersects = arrayIntersectsArray(outer, inner);\n  var contains = coordinatesContainPoint(outer, inner[0]);\n\n  if (!intersects && contains) {\n    return true;\n  }\n\n  return false;\n}; // do any polygons in this array contain any other polygons in this array?\n// used for checking for holes in arcgis rings\n\n\nvar convertRingsToGeoJSON = function convertRingsToGeoJSON(rings) {\n  var outerRings = [];\n  var holes = [];\n  var x; // iterator\n\n  var outerRing; // current outer ring being evaluated\n\n  var hole; // current hole being evaluated\n  // for each ring\n\n  for (var r = 0; r < rings.length; r++) {\n    var ring = closeRing(rings[r].slice(0));\n\n    if (ring.length < 4) {\n      continue;\n    } // is this ring an outer ring? is it clockwise?\n\n\n    if (ringIsClockwise(ring)) {\n      var polygon = [ring.slice().reverse()]; // wind outer rings counterclockwise for RFC 7946 compliance\n\n      outerRings.push(polygon); // push to outer rings\n    } else {\n      holes.push(ring.slice().reverse()); // wind inner rings clockwise for RFC 7946 compliance\n    }\n  }\n\n  var uncontainedHoles = []; // while there are holes left...\n\n  while (holes.length) {\n    // pop a hole off out stack\n    hole = holes.pop(); // loop over all outer rings and see if they contain our hole.\n\n    var contained = false;\n\n    for (x = outerRings.length - 1; x >= 0; x--) {\n      outerRing = outerRings[x][0];\n\n      if (coordinatesContainCoordinates(outerRing, hole)) {\n        // the hole is contained push it into our polygon\n        outerRings[x].push(hole);\n        contained = true;\n        break;\n      }\n    } // ring is not contained in any outer ring\n    // sometimes this happens https://github.com/Esri/esri-leaflet/issues/320\n\n\n    if (!contained) {\n      uncontainedHoles.push(hole);\n    }\n  } // if we couldn't match any holes using contains we can try intersects...\n\n\n  while (uncontainedHoles.length) {\n    // pop a hole off out stack\n    hole = uncontainedHoles.pop(); // loop over all outer rings and see if any intersect our hole.\n\n    var intersects = false;\n\n    for (x = outerRings.length - 1; x >= 0; x--) {\n      outerRing = outerRings[x][0];\n\n      if (arrayIntersectsArray(outerRing, hole)) {\n        // the hole is contained push it into our polygon\n        outerRings[x].push(hole);\n        intersects = true;\n        break;\n      }\n    }\n\n    if (!intersects) {\n      outerRings.push([hole.reverse()]);\n    }\n  }\n\n  if (outerRings.length === 1) {\n    return {\n      type: 'Polygon',\n      coordinates: outerRings[0]\n    };\n  } else {\n    return {\n      type: 'MultiPolygon',\n      coordinates: outerRings\n    };\n  }\n};\n\nvar getId = function getId(attributes, idAttribute) {\n  var keys = idAttribute ? [idAttribute, 'OBJECTID', 'FID'] : ['OBJECTID', 'FID'];\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n\n    if (key in attributes && (typeof attributes[key] === 'string' || typeof attributes[key] === 'number')) {\n      return attributes[key];\n    }\n  }\n\n  throw Error('No valid id attribute found');\n};\n\nvar arcgisToGeoJSON = function arcgisToGeoJSON(arcgis, idAttribute) {\n  var geojson = {};\n\n  if (arcgis.features) {\n    geojson.type = 'FeatureCollection';\n    geojson.features = [];\n\n    for (var i = 0; i < arcgis.features.length; i++) {\n      geojson.features.push(arcgisToGeoJSON(arcgis.features[i], idAttribute));\n    }\n  }\n\n  if (typeof arcgis.x === 'number' && typeof arcgis.y === 'number') {\n    geojson.type = 'Point';\n    geojson.coordinates = [arcgis.x, arcgis.y];\n\n    if (typeof arcgis.z === 'number') {\n      geojson.coordinates.push(arcgis.z);\n    }\n  }\n\n  if (arcgis.points) {\n    geojson.type = 'MultiPoint';\n    geojson.coordinates = arcgis.points.slice(0);\n  }\n\n  if (arcgis.paths) {\n    if (arcgis.paths.length === 1) {\n      geojson.type = 'LineString';\n      geojson.coordinates = arcgis.paths[0].slice(0);\n    } else {\n      geojson.type = 'MultiLineString';\n      geojson.coordinates = arcgis.paths.slice(0);\n    }\n  }\n\n  if (arcgis.rings) {\n    geojson = convertRingsToGeoJSON(arcgis.rings.slice(0));\n  }\n\n  if (typeof arcgis.xmin === 'number' && typeof arcgis.ymin === 'number' && typeof arcgis.xmax === 'number' && typeof arcgis.ymax === 'number') {\n    geojson.type = 'Polygon';\n    geojson.coordinates = [[[arcgis.xmax, arcgis.ymax], [arcgis.xmin, arcgis.ymax], [arcgis.xmin, arcgis.ymin], [arcgis.xmax, arcgis.ymin], [arcgis.xmax, arcgis.ymax]]];\n  }\n\n  if (arcgis.geometry || arcgis.attributes) {\n    geojson.type = 'Feature';\n    geojson.geometry = arcgis.geometry ? arcgisToGeoJSON(arcgis.geometry) : null;\n    geojson.properties = arcgis.attributes ? shallowClone(arcgis.attributes) : null;\n\n    if (arcgis.attributes) {\n      try {\n        geojson.id = getId(arcgis.attributes, idAttribute);\n      } catch (err) {// don't set an id\n      }\n    }\n  } // if no valid geometry was encountered\n\n\n  if (JSON.stringify(geojson.geometry) === JSON.stringify({})) {\n    geojson.geometry = null;\n  }\n\n  if (arcgis.spatialReference && arcgis.spatialReference.wkid && arcgis.spatialReference.wkid !== 4326) {\n    console.warn('Object converted in non-standard crs - ' + JSON.stringify(arcgis.spatialReference));\n  }\n\n  return geojson;\n};\n\n/* Copyright (c) 2012-2019 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n// outer rings are clockwise, holes are counterclockwise\n// used for converting GeoJSON Polygons to ArcGIS Polygons\n\nvar orientRings = function orientRings(poly) {\n  var output = [];\n  var polygon = poly.slice(0);\n  var outerRing = closeRing(polygon.shift().slice(0));\n\n  if (outerRing.length >= 4) {\n    if (!ringIsClockwise(outerRing)) {\n      outerRing.reverse();\n    }\n\n    output.push(outerRing);\n\n    for (var i = 0; i < polygon.length; i++) {\n      var hole = closeRing(polygon[i].slice(0));\n\n      if (hole.length >= 4) {\n        if (ringIsClockwise(hole)) {\n          hole.reverse();\n        }\n\n        output.push(hole);\n      }\n    }\n  }\n\n  return output;\n}; // This function flattens holes in multipolygons to one array of polygons\n// used for converting GeoJSON Polygons to ArcGIS Polygons\n\n\nvar flattenMultiPolygonRings = function flattenMultiPolygonRings(rings) {\n  var output = [];\n\n  for (var i = 0; i < rings.length; i++) {\n    var polygon = orientRings(rings[i]);\n\n    for (var x = polygon.length - 1; x >= 0; x--) {\n      var ring = polygon[x].slice(0);\n      output.push(ring);\n    }\n  }\n\n  return output;\n};\n\nvar geojsonToArcGIS = function geojsonToArcGIS(geojson, idAttribute) {\n  idAttribute = idAttribute || 'OBJECTID';\n  var spatialReference = {\n    wkid: 4326\n  };\n  var result = {};\n  var i;\n\n  switch (geojson.type) {\n    case 'Point':\n      result.x = geojson.coordinates[0];\n      result.y = geojson.coordinates[1];\n\n      if (geojson.coordinates[2]) {\n        result.z = geojson.coordinates[2];\n      }\n\n      result.spatialReference = spatialReference;\n      break;\n\n    case 'MultiPoint':\n      result.points = geojson.coordinates.slice(0);\n\n      if (geojson.coordinates[0][2]) {\n        result.hasZ = true;\n      }\n\n      result.spatialReference = spatialReference;\n      break;\n\n    case 'LineString':\n      result.paths = [geojson.coordinates.slice(0)];\n\n      if (geojson.coordinates[0][2]) {\n        result.hasZ = true;\n      }\n\n      result.spatialReference = spatialReference;\n      break;\n\n    case 'MultiLineString':\n      result.paths = geojson.coordinates.slice(0);\n\n      if (geojson.coordinates[0][0][2]) {\n        result.hasZ = true;\n      }\n\n      result.spatialReference = spatialReference;\n      break;\n\n    case 'Polygon':\n      result.rings = orientRings(geojson.coordinates.slice(0));\n\n      if (geojson.coordinates[0][0][2]) {\n        result.hasZ = true;\n      }\n\n      result.spatialReference = spatialReference;\n      break;\n\n    case 'MultiPolygon':\n      result.rings = flattenMultiPolygonRings(geojson.coordinates.slice(0));\n\n      if (geojson.coordinates[0][0][0][2]) {\n        result.hasZ = true;\n      }\n\n      result.spatialReference = spatialReference;\n      break;\n\n    case 'Feature':\n      if (geojson.geometry) {\n        result.geometry = geojsonToArcGIS(geojson.geometry, idAttribute);\n      }\n\n      result.attributes = geojson.properties ? shallowClone(geojson.properties) : {};\n\n      if (geojson.id) {\n        result.attributes[idAttribute] = geojson.id;\n      }\n\n      break;\n\n    case 'FeatureCollection':\n      result = [];\n\n      for (i = 0; i < geojson.features.length; i++) {\n        result.push(geojsonToArcGIS(geojson.features[i], idAttribute));\n      }\n\n      break;\n\n    case 'GeometryCollection':\n      result = [];\n\n      for (i = 0; i < geojson.geometries.length; i++) {\n        result.push(geojsonToArcGIS(geojson.geometries[i], idAttribute));\n      }\n\n      break;\n  }\n\n  return result;\n};\n\n/* Copyright (c) 2012-2019 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n\nexport { arcgisToGeoJSON, geojsonToArcGIS };\n","/* Copyright (c) 2017-2018 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n\nimport {\n  request,\n  cleanUrl,\n  ISpatialReference,\n  IPoint\n} from \"@esri/arcgis-rest-request\";\n\nimport {\n  ARCGIS_ONLINE_BULK_GEOCODING_URL,\n  IEndpointOptions\n} from \"./helpers.js\";\n\n// It would be better if doc did not display these properties in alphabetical order\nexport interface IAddressBulk {\n  /**\n   * A unique id must be passed along for each individual address.\n   */\n  OBJECTID: number;\n  address?: string;\n  address2?: string;\n  address3?: string;\n  neighborhood?: string;\n  city?: string;\n  subregion?: string;\n  /**\n   * The World Geocoding Service considers US states regions.\n   */\n  region?: string;\n  postal?: number;\n  postalExt?: number;\n  countryCode?: string;\n}\n\nexport interface IBulkGeocodeOptions extends IEndpointOptions {\n  addresses: IAddressBulk[];\n}\n\nexport interface IBulkGeocodeResponse {\n  spatialReference: ISpatialReference;\n  locations: Array<{\n    address: string;\n    location?: IPoint; // candidates with a score of 0 wont include a location\n    score: number;\n    attributes: object;\n  }>;\n}\n\n/**\n * Used to geocode a [batch](https://developers.arcgis.com/rest/geocode/api-reference/geocoding-geocode-addresses.htm) of addresses.\n *\n * ```js\n * import { bulkGeocode } from '@esri/arcgis-rest-geocoding';\n * import { ApplicationCredentialsManager } from '@esri/arcgis-rest-request';\n *\n * const addresses = [\n *   { \"OBJECTID\": 1, \"SingleLine\": \"380 New York Street 92373\" },\n *   { \"OBJECTID\": 2, \"SingleLine\": \"1 World Way Los Angeles 90045\" }\n * ];\n *\n * bulkGeocode({ addresses, authentication: session })\n *   .then((response) => {\n *     response.locations[0].location; // => { x: -117, y: 34, spatialReference: { wkid: 4326 } }\n *   });\n * ```\n *\n * @param requestOptions - Request options to pass to the geocoder, including an array of addresses and authentication session.\n * @returns A Promise that will resolve with the data from the response. The spatial reference will be added to address locations unless `rawResponse: true` was passed.\n */\nexport function bulkGeocode(\n  requestOptions: IBulkGeocodeOptions // must POST, which is the default\n): Promise<IBulkGeocodeResponse> {\n  const options: IBulkGeocodeOptions = {\n    endpoint: ARCGIS_ONLINE_BULK_GEOCODING_URL,\n    params: {},\n    ...requestOptions\n  };\n\n  options.params.addresses = {\n    records: requestOptions.addresses.map((address) => {\n      return { attributes: address };\n    })\n  };\n\n  // the SAS service does not support anonymous requests\n  if (\n    !requestOptions.authentication &&\n    options.endpoint === ARCGIS_ONLINE_BULK_GEOCODING_URL\n  ) {\n    return Promise.reject(\n      \"bulk geocoding using the ArcGIS service requires authentication\"\n    );\n  }\n\n  return request(\n    `${cleanUrl(options.endpoint)}/geocodeAddresses`,\n    options\n  ).then((response) => {\n    if (options.rawResponse) {\n      return response;\n    }\n    const sr = response.spatialReference;\n    response.locations.forEach(function (address: { location: IPoint }) {\n      if (address.location) {\n        address.location.spatialReference = sr;\n      }\n    });\n    return response;\n  });\n}\n","/* Copyright (c) 2017-2018 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n\nimport {\n  request,\n  cleanUrl,\n  appendCustomParams,\n  IExtent,\n  ISpatialReference,\n  IPoint\n} from \"@esri/arcgis-rest-request\";\n\nimport { ARCGIS_ONLINE_GEOCODING_URL, IEndpointOptions } from \"./helpers.js\";\n\nimport { arcgisToGeoJSON } from \"@terraformer/arcgis\";\n\nexport interface IGeocodeOptions extends IEndpointOptions {\n  /**\n   * use this if all your address info is contained in a single string.\n   */\n  singleLine?: string;\n  address?: string;\n  address2?: string;\n  address3?: string;\n  neighborhood?: string;\n  city?: string;\n  subregion?: string;\n  outFields?: \"*\" | string[];\n  /**\n   * The World Geocoding Service expects US states to be passed in as a 'region'.\n   */\n  region?: string;\n  postal?: number;\n  postalExt?: number;\n  countryCode?: string;\n  /**\n   * You can create an autocomplete experience by making a call to suggest with partial text and then passing through the magicKey and complete address that are returned to geocode.\n   *\n   * ```js\n   * import { suggest, geocode } from '@esri/arcgis-rest-geocoding';\n   *\n   * suggest(\"LAX\")\n   *   .then((response) => {\n   *     geocode({\n   *       singleLine: response.suggestions[1].text,\n   *       magicKey: response.suggestions[0].magicKey\n   *     })\n   *   })\n   * ```\n   */\n  magicKey?: string;\n}\n\nexport interface IGeocodeResponse {\n  spatialReference: ISpatialReference;\n  candidates: Array<{\n    address: string;\n    location: IPoint;\n    extent?: IExtent;\n    score: number;\n    attributes: object;\n  }>;\n  geoJson?: {\n    type: string;\n    features: Array<{\n      type: string;\n      geometry: object;\n      properties: any;\n    }>;\n  };\n}\n\n/**\n * Used to determine the location of a single address or point of interest. See the [REST Documentation](https://developers.arcgis.com/rest/geocode/api-reference/geocoding-find-address-candidates.htm) for more information.\n *\n *  ```js\n * import { geocode } from '@esri/arcgis-rest-geocoding';\n *\n * geocode(\"LAX\")\n *   .then((response) => {\n *     response.candidates[0].location; // => { x: -118.409, y: 33.943, spatialReference: ...  }\n *   });\n *\n * geocode({\n *   address: \"1600 Pennsylvania Ave\",\n *   postal: 20500,\n *   countryCode: \"USA\"\n * })\n *   .then((response) => {\n *     response.candidates[1].location; // => { x: -77.036533, y: 38.898719, spatialReference: ... }\n *   });\n * ```\n *\n * @param address String representing the address or point of interest or RequestOptions to pass to the endpoint.\n * @returns A Promise that will resolve with address candidates for the request. The spatial reference will be added to candidate locations and extents unless `rawResponse: true` was passed.\n */\nexport function geocode(\n  address: string | IGeocodeOptions\n): Promise<IGeocodeResponse> {\n  let options: IGeocodeOptions = {};\n  let endpoint: string;\n\n  if (typeof address === \"string\") {\n    options.params = { singleLine: address };\n    endpoint = ARCGIS_ONLINE_GEOCODING_URL;\n  } else {\n    endpoint = address.endpoint || ARCGIS_ONLINE_GEOCODING_URL;\n    options = appendCustomParams<IGeocodeOptions>(\n      address,\n      [\n        \"singleLine\",\n        \"address\",\n        \"address2\",\n        \"address3\",\n        \"neighborhood\",\n        \"city\",\n        \"subregion\",\n        \"region\",\n        \"postal\",\n        \"postalExt\",\n        \"countryCode\",\n        \"outFields\",\n        \"magicKey\"\n      ],\n      { params: { ...address.params } }\n    );\n  }\n\n  // add spatialReference property to individual matches\n  return request(`${cleanUrl(endpoint)}/findAddressCandidates`, options).then(\n    (response) => {\n      if (typeof address !== \"string\" && address.rawResponse) {\n        return response;\n      }\n      const sr: ISpatialReference = response.spatialReference;\n      response.candidates.forEach(function (candidate: {\n        location: IPoint;\n        extent?: IExtent;\n      }) {\n        candidate.location.spatialReference = sr;\n        if (candidate.extent) {\n          candidate.extent.spatialReference = sr;\n        }\n      });\n\n      // geoJson\n      if (sr.wkid === 4326) {\n        const features = response.candidates.map((candidate: any) => {\n          return {\n            type: \"Feature\",\n            geometry: arcgisToGeoJSON(candidate.location),\n            properties: Object.assign(\n              {\n                address: candidate.address,\n                score: candidate.score\n              },\n              candidate.attributes\n            )\n          };\n        });\n\n        response.geoJson = {\n          type: \"FeatureCollection\",\n          features\n        };\n      }\n\n      return response;\n    }\n  );\n}\n","/* Copyright (c) 2017-2018 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n\nimport {\n  request,\n  cleanUrl,\n  IPoint,\n  ILocation\n} from \"@esri/arcgis-rest-request\";\n\nimport { ARCGIS_ONLINE_GEOCODING_URL, IEndpointOptions } from \"./helpers.js\";\n\nexport interface IReverseGeocodeResponse {\n  address: {\n    [key: string]: any;\n  };\n  location: IPoint;\n}\n\nfunction isLocationArray(\n  coords: ILocation | IPoint | [number, number] | [number, number, number]\n): coords is [number, number] | [number, number, number] {\n  return (\n    (coords as [number, number]).length === 2 ||\n    (coords as [number, number, number]).length === 3\n  );\n}\n\nfunction isLocation(\n  coords: ILocation | IPoint | [number, number] | [number, number, number]\n): coords is ILocation {\n  return (\n    (coords as ILocation).latitude !== undefined ||\n    (coords as ILocation).lat !== undefined\n  );\n}\n\n/**\n * Used to determine the address of a [location](https://developers.arcgis.com/rest/geocode/api-reference/geocoding-reverse-geocode.htm).\n *\n * ```js\n * import { reverseGeocode } from '@esri/arcgis-rest-geocoding';\n * //\n * reverseGeocode([-118.409,33.943 ]) // long, lat\n *   .then((response) => {\n *     response.address.PlaceName; // => \"LA Airport\"\n *   });\n * // or\n * reverseGeocode({ long: -118.409, lat: 33.943 })\n * reverseGeocode({ latitude: 33.943, latitude: -118.409 })\n * reverseGeocode({ x: -118.409, y: 33.9425 }) // wgs84 is assumed\n * reverseGeocode({ x: -13181226, y: 4021085, spatialReference: { wkid: 3857 })\n * ```\n *\n * @param coordinates - the location you'd like to associate an address with.\n * @param requestOptions - Additional options for the request including authentication.\n * @returns A Promise that will resolve with the data from the response.\n */\nexport function reverseGeocode(\n  coords: IPoint | ILocation | [number, number],\n  requestOptions?: IEndpointOptions\n): Promise<IReverseGeocodeResponse> {\n  const options: IEndpointOptions = {\n    endpoint: ARCGIS_ONLINE_GEOCODING_URL,\n    params: {},\n    ...requestOptions\n  };\n\n  if (isLocationArray(coords)) {\n    options.params.location = coords.join();\n  } else if (isLocation(coords)) {\n    if (coords.lat) {\n      options.params.location = coords.long + \",\" + coords.lat;\n    }\n    if (coords.latitude) {\n      options.params.location = coords.longitude + \",\" + coords.latitude;\n    }\n  } else {\n    // if input is a point, we can pass it straight through, with or without a spatial reference\n    options.params.location = coords;\n  }\n\n  return request(`${cleanUrl(options.endpoint)}/reverseGeocode`, options);\n}\n\nexport default {\n  reverseGeocode\n};\n","/* Copyright (c) 2017-2018 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n\nimport { request, cleanUrl } from \"@esri/arcgis-rest-request\";\n\nimport { ARCGIS_ONLINE_GEOCODING_URL, IEndpointOptions } from \"./helpers.js\";\n\nexport interface ISuggestResponse {\n  suggestions: Array<{\n    text: string;\n    magicKey: string;\n    isCollection: boolean;\n  }>;\n}\n\n/**\n * Used to return a placename [suggestion](https://developers.arcgis.com/rest/geocode/api-reference/geocoding-suggest.htm) for a partial string.\n *\n * ```js\n * import { suggest } from '@esri/arcgis-rest-geocoding';\n * //\n * suggest(\"Starb\")\n *   .then(response) // response.text === \"Starbucks\"\n * ```\n *\n * @param requestOptions - Options for the request including authentication and other optional parameters.\n * @returns A Promise that will resolve with the data from the response.\n */\nexport function suggest(\n  partialText: string,\n  requestOptions?: IEndpointOptions\n): Promise<ISuggestResponse> {\n  const options: IEndpointOptions = {\n    endpoint: ARCGIS_ONLINE_GEOCODING_URL,\n    params: {},\n    ...requestOptions\n  };\n\n  options.params.text = partialText;\n\n  return request(`${cleanUrl(options.endpoint)}/suggest`, options);\n}\n\nexport default {\n  suggest\n};\n"],"names":["ARCGIS_ONLINE_GEOCODING_URL","ARCGIS_ONLINE_BULK_GEOCODING_URL","edgeIntersectsEdge","a1","a2","b1","b2","uaT","ubT","uB","ua","ub","arrayIntersectsArray","a","b","i","length","j","ringIsClockwise","ringToTest","pt2","total","rLength","pt1","coordinatesContainCoordinates","outer","inner","intersects","contains","coordinates","point","l","coordinatesContainPoint","arcgisToGeoJSON","arcgis","idAttribute","geojson","features","type","push","x","y","z","points","slice","paths","rings","outerRing","hole","outerRings","holes","r","ring","pointsEqual","polygon","reverse","uncontainedHoles","pop","contained","convertRingsToGeoJSON","xmin","ymin","xmax","ymax","geometry","attributes","properties","obj","target","hasOwnProperty","shallowClone","id","keys","key","Error","getId","err","JSON","stringify","spatialReference","wkid","console","warn","requestOptions","options","endpoint","params","addresses","records","map","address","authentication","request","cleanUrl","then","response","rawResponse","sr","locations","forEach","location","Promise","reject","singleLine","appendCustomParams","candidates","candidate","extent","Object","assign","score","geoJson","url","httpMethod","maxUrlLength","coords","isLocationArray","undefined","latitude","lat","isLocation","long","longitude","join","partialText","text"],"mappings":";;;;;sVAMaA,EACX,2EACWC,EACX;;;;;;ACDF,IAAIC,EAAqB,SAA4BC,EAAIC,EAAIC,EAAIC,GAC/D,IAAIC,GAAOD,EAAG,GAAKD,EAAG,KAAOF,EAAG,GAAKE,EAAG,KAAOC,EAAG,GAAKD,EAAG,KAAOF,EAAG,GAAKE,EAAG,IACxEG,GAAOJ,EAAG,GAAKD,EAAG,KAAOA,EAAG,GAAKE,EAAG,KAAOD,EAAG,GAAKD,EAAG,KAAOA,EAAG,GAAKE,EAAG,IACxEI,GAAMH,EAAG,GAAKD,EAAG,KAAOD,EAAG,GAAKD,EAAG,KAAOG,EAAG,GAAKD,EAAG,KAAOD,EAAG,GAAKD,EAAG,IAE3E,GAAW,IAAPM,EAAU,CACZ,IAAIC,EAAKH,EAAME,EACXE,EAAKH,EAAMC,EAEf,GAAIC,GAAM,GAAKA,GAAM,GAAKC,GAAM,GAAKA,GAAM,EACzC,OAAO,EAIX,OAAO,GAsBLC,EAAuB,SAA8BC,EAAGC,GAC1D,IAAK,IAAIC,EAAI,EAAGA,EAAIF,EAAEG,OAAS,EAAGD,IAChC,IAAK,IAAIE,EAAI,EAAGA,EAAIH,EAAEE,OAAS,EAAGC,IAChC,GAAIf,EAAmBW,EAAEE,GAAIF,EAAEE,EAAI,GAAID,EAAEG,GAAIH,EAAEG,EAAI,IACjD,OAAO,EAKb,OAAO,GAgBLC,EAAkB,SAAyBC,GAO7C,IANA,IAIIC,EAJAC,EAAQ,EACRN,EAAI,EACJO,EAAUH,EAAWH,OACrBO,EAAMJ,EAAWJ,GAGbA,EAAIO,EAAU,EAAGP,IAEvBM,KADAD,EAAMD,EAAWJ,EAAI,IACP,GAAKQ,EAAI,KAAOH,EAAI,GAAKG,EAAI,IAC3CA,EAAMH,EAGR,OAAOC,GAAS,GAqBdG,EAAgC,SAAuCC,EAAOC,GAChF,IAAIC,EAAaf,EAAqBa,EAAOC,GACzCE,EAjFwB,SAAiCC,EAAaC,GAG1E,IAFA,IAAIF,GAAW,EAENb,GAAK,EAAGgB,EAAIF,EAAYb,OAAQC,EAAIc,EAAI,IAAKhB,EAAIgB,EAAGd,EAAIF,GAC1Dc,EAAYd,GAAG,IAAMe,EAAM,IAAMA,EAAM,GAAKD,EAAYZ,GAAG,IAAMY,EAAYZ,GAAG,IAAMa,EAAM,IAAMA,EAAM,GAAKD,EAAYd,GAAG,KAAOe,EAAM,IAAMD,EAAYZ,GAAG,GAAKY,EAAYd,GAAG,KAAOe,EAAM,GAAKD,EAAYd,GAAG,KAAOc,EAAYZ,GAAG,GAAKY,EAAYd,GAAG,IAAMc,EAAYd,GAAG,KACrRa,GAAYA,GAIhB,OAAOA,EAwEQI,CAAwBP,EAAOC,EAAM,IAEpD,QAAKC,IAAcC,IAgHjBK,EAAkB,SAASA,EAAgBC,EAAQC,GACrD,IAAIC,EAAU,GAEd,GAAIF,EAAOG,SAAU,CACnBD,EAAQE,KAAO,oBACfF,EAAQC,SAAW,GAEnB,IAAK,IAAItB,EAAI,EAAGA,EAAImB,EAAOG,SAASrB,OAAQD,IAC1CqB,EAAQC,SAASE,KAAKN,EAAgBC,EAAOG,SAAStB,GAAIoB,IAqC9D,GAjCwB,iBAAbD,EAAOM,GAAsC,iBAAbN,EAAOO,IAChDL,EAAQE,KAAO,QACfF,EAAQP,YAAc,CAACK,EAAOM,EAAGN,EAAOO,GAEhB,iBAAbP,EAAOQ,GAChBN,EAAQP,YAAYU,KAAKL,EAAOQ,IAIhCR,EAAOS,SACTP,EAAQE,KAAO,aACfF,EAAQP,YAAcK,EAAOS,OAAOC,MAAM,IAGxCV,EAAOW,QACmB,IAAxBX,EAAOW,MAAM7B,QACfoB,EAAQE,KAAO,aACfF,EAAQP,YAAcK,EAAOW,MAAM,GAAGD,MAAM,KAE5CR,EAAQE,KAAO,kBACfF,EAAQP,YAAcK,EAAOW,MAAMD,MAAM,KAIzCV,EAAOY,QACTV,EA5IwB,SAA+BU,GAUzD,IATA,IAEIN,EAEAO,EAEAC,EAhE6BnB,EA0D7BoB,EAAa,GACbC,EAAQ,GAQHC,EAAI,EAAGA,EAAIL,EAAM9B,OAAQmC,IAAK,CACrC,IAAIC,GA5FU,SAAqBvC,EAAGC,GACxC,IAAK,IAAIC,EAAI,EAAGA,EAAIF,EAAEG,OAAQD,IAC5B,GAAIF,EAAEE,KAAOD,EAAEC,GACb,OAAO,EAIX,OAAO,EAkBFsC,EAD4BxB,EAoEViB,EAAMK,GAAGP,MAAM,IAnET,GAAIf,EAAYA,EAAYb,OAAS,KAChEa,EAAYU,KAAKV,EAAY,IAGxBA,GAiEL,KAAIuB,EAAKpC,OAAS,GAKlB,GAAIE,EAAgBkC,GAAO,CACzB,IAAIE,EAAU,CAACF,EAAKR,QAAQW,WAE5BN,EAAWV,KAAKe,QAEhBJ,EAAMX,KAAKa,EAAKR,QAAQW,WAM5B,IAFA,IAAIC,EAAmB,GAEhBN,EAAMlC,QAAQ,CAEnBgC,EAAOE,EAAMO,MAEb,IAAIC,GAAY,EAEhB,IAAKlB,EAAIS,EAAWjC,OAAS,EAAGwB,GAAK,EAAGA,IAGtC,GAFAO,EAAYE,EAAWT,GAAG,GAEtBhB,EAA8BuB,EAAWC,GAAO,CAElDC,EAAWT,GAAGD,KAAKS,GACnBU,GAAY,EACZ,MAMCA,GACHF,EAAiBjB,KAAKS,GAK1B,KAAOQ,EAAiBxC,QAAQ,CAE9BgC,EAAOQ,EAAiBC,MAExB,IAAI9B,GAAa,EAEjB,IAAKa,EAAIS,EAAWjC,OAAS,EAAGwB,GAAK,EAAGA,IAGtC,GAFAO,EAAYE,EAAWT,GAAG,GAEtB5B,EAAqBmC,EAAWC,GAAO,CAEzCC,EAAWT,GAAGD,KAAKS,GACnBrB,GAAa,EACb,MAICA,GACHsB,EAAWV,KAAK,CAACS,EAAKO,YAI1B,OAA0B,IAAtBN,EAAWjC,OACN,CACLsB,KAAM,UACNT,YAAaoB,EAAW,IAGnB,CACLX,KAAM,eACNT,YAAaoB,GAwDLU,CAAsBzB,EAAOY,MAAMF,MAAM,KAG1B,iBAAhBV,EAAO0B,MAA4C,iBAAhB1B,EAAO2B,MAA4C,iBAAhB3B,EAAO4B,MAA4C,iBAAhB5B,EAAO6B,OACzH3B,EAAQE,KAAO,UACfF,EAAQP,YAAc,CAAC,CAAC,CAACK,EAAO4B,KAAM5B,EAAO6B,MAAO,CAAC7B,EAAO0B,KAAM1B,EAAO6B,MAAO,CAAC7B,EAAO0B,KAAM1B,EAAO2B,MAAO,CAAC3B,EAAO4B,KAAM5B,EAAO2B,MAAO,CAAC3B,EAAO4B,KAAM5B,EAAO6B,UAG3J7B,EAAO8B,UAAY9B,EAAO+B,cAC5B7B,EAAQE,KAAO,UACfF,EAAQ4B,SAAW9B,EAAO8B,SAAW/B,EAAgBC,EAAO8B,UAAY,KACxE5B,EAAQ8B,WAAahC,EAAO+B,WArLb,SAAsBE,GACvC,IAAIC,EAAS,GAEb,IAAK,IAAIrD,KAAKoD,EAERA,EAAIE,eAAetD,KAErBqD,EAAOrD,GAAKoD,EAAIpD,IAIpB,OAAOqD,EA0KoCE,CAAapC,EAAO+B,YAAc,KAEvE/B,EAAO+B,YACT,IACE7B,EAAQmC,GAlEJ,SAAeN,EAAY9B,GAGrC,IAFA,IAAIqC,EAAOrC,EAAc,CAACA,EAAa,WAAY,OAAS,CAAC,WAAY,OAEhEpB,EAAI,EAAGA,EAAIyD,EAAKxD,OAAQD,IAAK,CACpC,IAAI0D,EAAMD,EAAKzD,GAEf,GAAI0D,KAAOR,IAA0C,iBAApBA,EAAWQ,IAAgD,iBAApBR,EAAWQ,IACjF,OAAOR,EAAWQ,GAItB,MAAMC,MAAM,+BAuDOC,CAAMzC,EAAO+B,WAAY9B,GACtC,MAAOyC,IAcb,OARIC,KAAKC,UAAU1C,EAAQ4B,YAAca,KAAKC,UAAU,MACtD1C,EAAQ4B,SAAW,MAGjB9B,EAAO6C,kBAAoB7C,EAAO6C,iBAAiBC,MAAyC,OAAjC9C,EAAO6C,iBAAiBC,MACrFC,QAAQC,KAAK,0CAA4CL,KAAKC,UAAU5C,EAAO6C,mBAG1E3C,+FCtNP+C,GAEA,MAAMC,iBACJC,SAAUpF,EACVqF,OAAQ,IACLH,GAUL,OAPAC,EAAQE,OAAOC,UAAY,CACzBC,QAASL,EAAeI,UAAUE,KAAKC,IAC9B,CAAEzB,WAAYyB,OAMtBP,EAAeQ,gBAChBP,EAAQC,WAAapF,EAOhB2F,UACL,GAAGC,WAAST,EAAQC,6BACpBD,GACAU,MAAMC,IACN,GAAIX,EAAQY,YACV,OAAOD,EAET,MAAME,EAAKF,EAAShB,iBAMpB,OALAgB,EAASG,UAAUC,SAAQ,SAAUT,GAC/BA,EAAQU,WACVV,EAAQU,SAASrB,iBAAmBkB,MAGjCF,KAlBAM,QAAQC,OACb,uFCKJZ,GAEA,IACIL,EADAD,EAA2B,GA8B/B,MA3BuB,iBAAZM,GACTN,EAAQE,OAAS,CAAEiB,WAAYb,GAC/BL,EAAWrF,IAEXqF,EAAWK,EAAQL,UAAYrF,EAC/BoF,EAAUoB,qBACRd,EACA,CACE,aACA,UACA,WACA,WACA,eACA,OACA,YACA,SACA,SACA,YACA,cACA,YACA,YAEF,CAAEJ,wBAAaI,EAAQJ,WAKpBM,UAAQ,GAAGC,WAASR,2BAAmCD,GAASU,MACpEC,IACC,GAAuB,iBAAZL,GAAwBA,EAAQM,YACzC,OAAOD,EAET,MAAME,EAAwBF,EAAShB,iBAYvC,GAXAgB,EAASU,WAAWN,SAAQ,SAAUO,GAIpCA,EAAUN,SAASrB,iBAAmBkB,EAClCS,EAAUC,SACZD,EAAUC,OAAO5B,iBAAmBkB,MAKxB,OAAZA,EAAGjB,KAAe,CACpB,MAAM3C,EAAW0D,EAASU,WAAWhB,KAAKiB,IACjC,CACLpE,KAAM,UACN0B,SAAU/B,EAAgByE,EAAUN,UACpClC,WAAY0C,OAAOC,OACjB,CACEnB,QAASgB,EAAUhB,QACnBoB,MAAOJ,EAAUI,OAEnBJ,EAAUzC,gBAKhB8B,EAASgB,QAAU,CACjBzE,KAAM,oBACND,SAAAA,GAIJ,OAAO0D,mCH5HXZ,GAEA,MAAM6B,EACH7B,GAAkBA,EAAeE,UAAarF,EAE3CoF,iBACJ6B,WAAY,MACZC,aAAc,KACX/B,GAGL,OAAOS,UAAQoB,EAAK5B,8BIKpB+B,EACAhC,GAEA,MAAMC,iBACJC,SAAUrF,EACVsF,OAAQ,IACLH,GAiBL,OA/DF,SACEgC,GAEA,OAC0C,IAAvCA,EAA4BnG,QACmB,IAA/CmG,EAAoCnG,OA4CnCoG,CAAgBD,IAxCtB,SACEA,GAEA,YACqCE,IAAlCF,EAAqBG,eACQD,IAA7BF,EAAqBI,IAqCbC,CAAWL,GASpB/B,EAAQE,OAAOc,SAAWe,GARtBA,EAAOI,MACTnC,EAAQE,OAAOc,SAAWe,EAAOM,KAAO,IAAMN,EAAOI,KAEnDJ,EAAOG,WACTlC,EAAQE,OAAOc,SAAWe,EAAOO,UAAY,IAAMP,EAAOG,WAN5DlC,EAAQE,OAAOc,SAAWe,EAAOQ,OAa5B/B,UAAQ,GAAGC,WAAST,EAAQC,2BAA4BD,uBCrD/DwC,EACAzC,GAEA,MAAMC,iBACJC,SAAUrF,EACVsF,OAAQ,IACLH,GAKL,OAFAC,EAAQE,OAAOuC,KAAOD,EAEfhC,UAAQ,GAAGC,WAAST,EAAQC,oBAAqBD"}